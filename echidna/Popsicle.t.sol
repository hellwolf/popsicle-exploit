// SPDX-License-Identifier: agpl-3.0
pragma solidity >=0.7.0;

import "Popsicle.sol";

contract PopsicleTester is Popsicle {

    mapping (address => uint256) private rewards;

    // deposit assets (ETH) to the system in exchange for shares
    function deposit() override public payable {
        uint balanceBefore = balanceOf(msg.sender);
        Popsicle.deposit();
        uint balanceAfter = balanceOf(msg.sender);
        assert(balanceAfter - balanceBefore == msg.value);
    }

    // withdraw assets (shares) from the system
    function withdraw(uint amount) override public {
        uint balanceBefore = balanceOf(msg.sender);
        Popsicle.withdraw(amount);
        uint balanceAfter = balanceOf(msg.sender);
        assert(balanceBefore - balanceAfter == amount);
    }

    function transfer(address recipient, uint256 amount) override public returns (bool) {
        uint balanceBefore1 = balanceOf(msg.sender);
        uint balanceBefore2 = balanceOf(recipient);
        bool ret = Popsicle.transfer(recipient, amount);
        uint balanceAfter1 = balanceOf(msg.sender);
        uint balanceAfter2 = balanceOf(recipient);
        assert(balanceBefore1 - balanceAfter1 == amount);
        assert(balanceAfter2 - balanceBefore2 == amount);
        return ret;
    }

    // collect fees
    function collectFees() override public {
        Popsicle.collectFees();
        rewards[msg.sender] = 0;
    }
    
    function OwnerDoItsJobAndEarnsFeesToItsClients() override public payable {
        Popsicle.OwnerDoItsJobAndEarnsFeesToItsClients();
	    rewards[address(0x10000)] += balanceOf(address(0x10000));
    	rewards[address(0x20000)] += balanceOf(address(0x20000));
    	rewards[address(0x30000)] += balanceOf(address(0x30000)); 
    }

    function collectFeesInvariant() external {
        uint expected_rewards = rewards[msg.sender];
        uint amount_old = msg.sender.balance; 
        collectFees();
        uint amount_new = msg.sender.balance;
        assert(amount_new - amount_old == expected_rewards);
    }
}
