// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity >=0.7.0;

import "ds-test/test.sol";

import "./Popsicle.sol";

contract TokenUser {

    Popsicle p;

    constructor(Popsicle p_) {
        p = p_;
    }

    function deposit(uint amount) external {
        p.deposit{value : amount}();
    }

    function withdraw(uint amount) external {
        p.withdraw(amount);
    }

    function collectFees() external {
        p.collectFees();
    }

    function OwnerDoItsJobAndEarnsFeesToItsClients() external {
        p.OwnerDoItsJobAndEarnsFeesToItsClients();
    }

    function transferToken(address to, uint amount) external {
        p.transfer(to, amount);
    }

    receive() external payable { }
}

contract PopsicleTest is DSTest {

    uint64 private constant INIT_USER_BALANCE = type(uint64).max;

    Popsicle popsicle;

    TokenUser bob;
    TokenUser alice;

    function setUp() public {
        popsicle = new Popsicle();
        bob = new TokenUser(popsicle);
        alice = new TokenUser(popsicle);
        payable(address(bob)).transfer(INIT_USER_BALANCE);
        payable(address(alice)).transfer(INIT_USER_BALANCE);
    }

    //
    // Single functional requirements test cases
    //
    function hevm_crashes___prove_something(uint64 amount) public {
        assertTrue(popsicle.balanceOf(address(bob)) == 0);
        bob.deposit(amount);
        assertEq(popsicle.balanceOf(address(bob)), amount);
    }

    function test_deposit(uint64 amount) public {
        assertTrue(popsicle.balanceOf(address(bob)) == 0);
        bob.deposit(amount);
        assertEq(popsicle.balanceOf(address(bob)), amount);
    }

    function test_collectFees(uint64 amount) public {
        bob.deposit(amount);
        popsicle.OwnerDoItsJobAndEarnsFeesToItsClients{value : amount}();
        uint256 oldETHAmount = address(bob).balance;
        bob.collectFees();
        uint256 newETHAmount = address(bob).balance;
        assertEq(newETHAmount - oldETHAmount, amount);
        bob.withdraw(amount);
    }

    //
    // rewardInvariance test cases
    //

    function test_rewardInvariance_simple(uint64 amount) public {
        bob.deposit(amount);
        bob.transferToken(address(alice), amount);
        assertEq(popsicle.balanceOf(address(bob)), 0);
        assertEq(popsicle.balanceOf(address(alice)), amount);
    }

    function test_rewardInvariance_exploit() public {
        bob.deposit(10 ether);
        popsicle.OwnerDoItsJobAndEarnsFeesToItsClients{value : 80 ether}();
        alice.deposit(10 ether);
        alice.transferToken(address(bob), 10 ether);
        uint256 oldETHAmount = address(bob).balance;
        bob.collectFees();
        uint256 newETHAmount = address(bob).balance;
        assertEq(newETHAmount - oldETHAmount, 10 ether);
        // THIS IS THE EXPLOIT: assertEq(newETHAmount - oldETHAmount, 20 ether);
    }

    function test_rewardInvariance_complex(uint8[6] memory ops, uint64 amount) public {
        uint rewardsToBeDistributedAlice = 0;
        uint rewardsToBeDistributedBob = 0;
        uint expectedTotalSupply = amount;
        bob.deposit(amount);
        emit log_named_uint("bob deposit", amount);
        for (uint8 i = 0; i < ops.length; i++) {
            uint8 op = ops[i] % 6;
               if (op == 0) { // alice withdraws
                emit log("alice withdraw");
                uint256 oldAmount = popsicle.balanceOf(address(alice));
                uint256 someAmount = oldAmount / 100;
                alice.withdraw(someAmount);
                expectedTotalSupply -= someAmount;
                emit log_named_uint("  someAmount", someAmount);
                assertEq(popsicle.balanceOf(address(alice)) + popsicle.balanceOf(address(bob)), expectedTotalSupply);
            } else if (op == 1) { // bob -> alice
                emit log("bob -> alice");
                uint256 oldAliceAmount = popsicle.balanceOf(address(alice));
                uint256 oldBobAmount = popsicle.balanceOf(address(bob));
                uint256 someAmount = oldBobAmount / 100;
                bob.transferToken(address(alice), someAmount);
                emit log_named_uint("  someAmount", someAmount);
                assertEq(popsicle.balanceOf(address(alice)), oldAliceAmount + someAmount);
                assertEq(popsicle.balanceOf(address(bob)), oldBobAmount - someAmount);
                assertEq(popsicle.balanceOf(address(alice)) + popsicle.balanceOf(address(bob)), expectedTotalSupply);
            } else if (op == 2) {
                emit log("alice -> bob");
                uint256 oldAliceAmount = popsicle.balanceOf(address(alice));
                uint256 oldBobAmount = popsicle.balanceOf(address(bob));
                uint256 someAmount = oldAliceAmount / 100;
                alice.transferToken(address(bob), someAmount);
                emit log_named_uint("  someAmount", someAmount);
                assertEq(popsicle.balanceOf(address(alice)), oldAliceAmount - someAmount);
                assertEq(popsicle.balanceOf(address(bob)), oldBobAmount + someAmount);
                assertEq(popsicle.balanceOf(address(alice)) + popsicle.balanceOf(address(bob)), expectedTotalSupply);
            } else if (op == 3) {
                emit log("alice collectFees");
                uint256 oldAmount = address(alice).balance;
                alice.collectFees();
                uint256 newAmount = address(alice).balance;
                emit log_named_uint("  rewardsToBeDistributedAlice", rewardsToBeDistributedAlice);
                emit log_named_uint("  rewards distributed to alice", newAmount - oldAmount);
                assertEq(rewardsToBeDistributedAlice, newAmount - oldAmount);
                rewardsToBeDistributedAlice = 0;
                assertEq(popsicle.balanceOf(address(alice)) + popsicle.balanceOf(address(bob)), expectedTotalSupply);
            } else if (op == 4) {
                emit log("bob collectFees");
                uint256 oldAmount = address(bob).balance;
                bob.collectFees();
                uint256 newAmount = address(bob).balance;
                emit log_named_uint("  rewardsToBeDistributedBob", rewardsToBeDistributedBob);
                emit log_named_uint("  rewards distributed to bob", newAmount - oldAmount);
                assertEq(rewardsToBeDistributedBob, newAmount - oldAmount);
                rewardsToBeDistributedBob = 0;
                assertEq(popsicle.balanceOf(address(alice)) + popsicle.balanceOf(address(bob)), expectedTotalSupply);
            } else if (op == 5) {
                emit log("OwnerDoItsJobAndEarnsFeesToItsClients");
                assertEq(popsicle.balanceOf(address(alice)) + popsicle.balanceOf(address(bob)), expectedTotalSupply);
                popsicle.OwnerDoItsJobAndEarnsFeesToItsClients{value: expectedTotalSupply}();
                rewardsToBeDistributedAlice += popsicle.balanceOf(address(alice));
                rewardsToBeDistributedBob += popsicle.balanceOf(address(bob));
                emit log_named_uint("  rewardsToBeDistributedAlice", rewardsToBeDistributedAlice);
                emit log_named_uint("  rewardsToBeDistributedBob", rewardsToBeDistributedBob);
            } else assertTrue(false);
        }
    }
}
